'use client';

import { useState, useEffect } from 'react';
import { Content, User } from '@/types/firebase';
import { contentService } from '@/lib/firestore';
import { doc, getDoc } from 'firebase/firestore';
import { db } from '@/lib/firebase';
import ContentCard from './ContentCard';
import SearchPerformanceMonitor from '@/components/debug/SearchPerformanceMonitor';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import { 
  Loader2, 
  Search, 
  AlertCircle,
  RefreshCw
} from 'lucide-react';

interface ContentWithCreator extends Content {
  creatorName?: string;
  creatorImage?: string;
  isCreator?: boolean;
}

interface SearchFilters {
  query: string;
  type: string;
  tool: string;
  priceRange: string;
  sortBy: string;
  tags: string[];
}

interface ContentGridProps {
  filters: SearchFilters;
  viewMode: 'grid' | 'list';
}

export default function ContentGrid({ filters, viewMode }: ContentGridProps) {
  const [contents, setContents] = useState<ContentWithCreator[]>([]);
  const [loading, setLoading] = useState(true);
  const [loadingMore, setLoadingMore] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(true);
  const [lastDoc, setLastDoc] = useState<any>(null);
  const [searchPerformance, setSearchPerformance] = useState<any>(null);
  const [showPerformanceMonitor, setShowPerformanceMonitor] = useState(false);

  // ÏΩòÌÖêÏ∏† Î°úÎìú
  const loadContents = async (isLoadMore = false) => {
    if (isLoadMore) {
      setLoadingMore(true);
    } else {
      setLoading(true);
      setContents([]);
      setLastDoc(null);
      setHasMore(true);
    }
    
    setError(null);

    try {
      const startTime = performance.now();

      // Í≤ÄÏÉâ ÌååÎùºÎØ∏ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ searchContents ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ getContents ÏÇ¨Ïö©
      const hasSearchParams = filters.query || filters.type || filters.tool ||
                             filters.priceRange || filters.sortBy !== 'latest' ||
                             filters.tags.length > 0;

      let result;
      if (hasSearchParams) {
        console.log('üîç Í≤ÄÏÉâ API ÏÇ¨Ïö©:', filters);
        result = await contentService.searchContents({
          query: filters.query,
          type: filters.type,
          tool: filters.tool,
          priceRange: filters.priceRange,
          sortBy: filters.sortBy,
          tags: filters.tags,
          limit: 12,
          lastDoc: isLoadMore ? lastDoc : undefined
        });
      } else {
        console.log('üìã Í∏∞Î≥∏ Î™©Î°ù API ÏÇ¨Ïö©');
        result = await contentService.getContents(
          12, // ÌéòÏù¥ÏßÄ ÌÅ¨Í∏∞
          isLoadMore ? lastDoc : undefined
        );
      }

      const endTime = performance.now();
      const searchTime = Math.round(endTime - startTime);

      // ÏÑ±Îä• Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
      if (!isLoadMore) {
        setSearchPerformance({
          searchTime,
          searchInfo: result.searchInfo,
          query: filters.query,
          filters,
          timestamp: Date.now()
        });
        setShowPerformanceMonitor(hasSearchParams); // Í≤ÄÏÉâ/ÌïÑÌÑ∞Í∞Ä ÏûàÏùÑ ÎïåÎßå ÌëúÏãú
      }

      if (result.success) {
        let newContents = result.data;

        // Í≤ÄÏÉâ APIÎ•º ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ÏóêÎßå ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÌïÑÌÑ∞ÎßÅ Ï†ÅÏö©
        if (!hasSearchParams) {
          newContents = applyFilters(newContents, filters);
        }

        console.log('üìä Î°úÎìúÎêú ÏΩòÌÖêÏ∏† Ïàò:', newContents.length);

        // ÌÅ¨Î¶¨ÏóêÏù¥ÌÑ∞ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ Î∞è ÌÖåÏä§Ìä∏Ïö© Í∞§Îü¨Î¶¨ Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
        const contentsWithCreators = await Promise.all(
          newContents.map(async (content, index) => {
            try {
              const userDoc = await getDoc(doc(db, 'users', content.creatorId));
              let contentWithCreator = content;

              if (userDoc.exists()) {
                const userData = userDoc.data() as User;
                contentWithCreator = {
                  ...content,
                  creatorName: userData.name,
                  creatorImage: userData.profileImage,
                  isCreator: userData.roles.includes('creator')
                };
              }

              // Ïã§Ï†ú ÏΩòÌÖêÏ∏†Ïùò Í∞§Îü¨Î¶¨ Ïù¥ÎØ∏ÏßÄ ÏÇ¨Ïö© (explore ÌéòÏù¥ÏßÄÏö©)
              // Ïã§Ï†ú Í∞§Îü¨Î¶¨ Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ ÏÇ¨Ïö©
              if (contentWithCreator.galleryImages && contentWithCreator.galleryImages.length > 0) {
                // galleryImagesÏóêÏÑú URLÎßå Ï∂îÏ∂úÌïòÏó¨ galleryURLsÎ°ú Î≥ÄÌôò
                const galleryURLs = contentWithCreator.galleryImages
                  .filter(img => img.url && !img.url.startsWith('blob:')) // Ïú†Ìö®Ìïú URLÎßå ÌïÑÌÑ∞ÎßÅ
                  .map(img => img.url);

                if (galleryURLs.length > 0) {
                  return {
                    ...contentWithCreator,
                    galleryURLs: galleryURLs
                  };
                }
              }

              // Í∏∞Ï°¥ galleryURLsÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©
              if (contentWithCreator.galleryURLs && contentWithCreator.galleryURLs.length > 0) {
                return {
                  ...contentWithCreator,
                  galleryURLs: contentWithCreator.galleryURLs
                };
              }

              return contentWithCreator;
            } catch (error) {
              console.error('ÌÅ¨Î¶¨ÏóêÏù¥ÌÑ∞ Ï†ïÎ≥¥ Î°úÎìú Ïò§Î•ò:', error);
              return content;
            }
          })
        );

        if (isLoadMore) {
          // ÎçîÎ≥¥Í∏∞ Ïãú Ï§ëÎ≥µ Ï†úÍ±∞
          setContents(prev => {
            const existingIds = new Set(prev.map(c => c.id));
            const newUniqueContents = contentsWithCreators.filter(c => !existingIds.has(c.id));
            return [...prev, ...newUniqueContents];
          });
        } else {
          setContents(contentsWithCreators);
        }

        setLastDoc(result.lastDoc);
        setHasMore(contentsWithCreators.length === 12);
      } else {
        throw new Error(result.error);
      }
    } catch (error: any) {
      console.error('ContentGrid Ïò§Î•ò:', error);

      if (error.message.includes('index')) {
        setError('Í≤ÄÏÉâ Ïù∏Îç±Ïä§Î•º ÏÉùÏÑ± Ï§ëÏûÖÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
      } else {
        setError(error.message || 'ÏΩòÌÖêÏ∏†Î•º Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
      }
    } finally {
      setLoading(false);
      setLoadingMore(false);
    }
  };

  // ÌïÑÌÑ∞ Ï†ÅÏö© Ìï®Ïàò
  const applyFilters = (contents: Content[], filters: SearchFilters): Content[] => {
    let filtered = [...contents];

    // Í≤ÄÏÉâÏñ¥ ÌïÑÌÑ∞
    if (filters.query) {
      const query = filters.query.toLowerCase();
      filtered = filtered.filter(content =>
        content.title.toLowerCase().includes(query) ||
        content.description.toLowerCase().includes(query) ||
        content.tags.some(tag => tag.toLowerCase().includes(query))
      );
    }

    // ÏΩòÌÖêÏ∏† Ïú†Ìòï ÌïÑÌÑ∞
    if (filters.type) {
      filtered = filtered.filter(content => content.type === filters.type);
    }

    // AI ÎèÑÍµ¨ ÌïÑÌÑ∞
    if (filters.tool) {
      filtered = filtered.filter(content => content.tool === filters.tool);
    }

    // Í∞ÄÍ≤© Î≤îÏúÑ ÌïÑÌÑ∞
    if (filters.priceRange) {
      filtered = filtered.filter(content => {
        switch (filters.priceRange) {
          case 'free':
            return content.price === 0;
          case '0-5000':
            return content.price > 0 && content.price <= 5000;
          case '5000-20000':
            return content.price > 5000 && content.price <= 20000;
          case '20000-50000':
            return content.price > 20000 && content.price <= 50000;
          case '50000+':
            return content.price > 50000;
          default:
            return true;
        }
      });
    }

    // ÌÉúÍ∑∏ ÌïÑÌÑ∞
    if (filters.tags.length > 0) {
      filtered = filtered.filter(content =>
        filters.tags.some(tag => content.tags.includes(tag))
      );
    }

    // Ï†ïÎ†¨
    switch (filters.sortBy) {
      case 'popular':
        filtered.sort((a, b) => (b.likes + b.downloads) - (a.likes + a.downloads));
        break;
      case 'downloads':
        filtered.sort((a, b) => b.downloads - a.downloads);
        break;
      case 'price-low':
        filtered.sort((a, b) => a.price - b.price);
        break;
      case 'price-high':
        filtered.sort((a, b) => b.price - a.price);
        break;
      case 'latest':
      default:
        filtered.sort((a, b) => b.createdAt.seconds - a.createdAt.seconds);
        break;
    }

    return filtered;
  };

  // ÌïÑÌÑ∞ Î≥ÄÍ≤Ω Ïãú ÏΩòÌÖêÏ∏† Îã§Ïãú Î°úÎìú
  useEffect(() => {
    loadContents();
  }, [filters]);

  // Ï¢ãÏïÑÏöî Ï≤òÎ¶¨
  const handleLike = (contentId: string, isLiked: boolean) => {
    setContents(prev =>
      prev.map(content =>
        content.id === contentId
          ? { ...content, likes: content.likes + (isLiked ? 1 : -1) }
          : content
      )
    );
  };

  // Î°úÎî© Ïä§ÏºàÎ†àÌÜ§
  const renderSkeleton = () => (
    <div className={viewMode === 'grid' 
      ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6"
      : "space-y-4"
    }>
      {Array.from({ length: 8 }).map((_, index) => (
        <Card key={index}>
          <Skeleton className="aspect-video w-full" />
          <CardContent className="p-4">
            <Skeleton className="h-6 w-3/4 mb-2" />
            <Skeleton className="h-4 w-full mb-2" />
            <Skeleton className="h-4 w-2/3" />
          </CardContent>
        </Card>
      ))}
    </div>
  );

  // ÏóêÎü¨ ÏÉÅÌÉú
  if (error) {
    return (
      <Card className="p-8 text-center">
        <AlertCircle className="w-12 h-12 text-red-500 mx-auto mb-4" />
        <h3 className="text-lg font-semibold mb-2">Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§</h3>
        <p className="text-muted-foreground mb-4">{error}</p>
        <Button onClick={() => loadContents()} variant="outline">
          <RefreshCw className="w-4 h-4 mr-2" />
          Îã§Ïãú ÏãúÎèÑ
        </Button>
      </Card>
    );
  }

  // Î°úÎî© ÏÉÅÌÉú
  if (loading) {
    return renderSkeleton();
  }

  // Îπà Í≤∞Í≥º
  if (contents.length === 0) {
    return (
      <Card className="p-8 text-center">
        <Search className="w-12 h-12 text-muted-foreground mx-auto mb-4" />
        <h3 className="text-lg font-semibold mb-2">Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§</h3>
        <p className="text-muted-foreground mb-4">
          Îã§Î•∏ Í≤ÄÏÉâÏñ¥ÎÇò ÌïÑÌÑ∞Î•º ÏãúÎèÑÌï¥Î≥¥ÏÑ∏Ïöî.
        </p>
        <Button onClick={() => loadContents()} variant="outline">
          Ï†ÑÏ≤¥ ÏΩòÌÖêÏ∏† Î≥¥Í∏∞
        </Button>
      </Card>
    );
  }

  return (
    <div className="space-y-6">
      {/* Í≤∞Í≥º Í∞úÏàò */}
      <div className="flex items-center justify-between">
        <p className="text-sm text-muted-foreground">
          Ï¥ù {contents.length}Í∞úÏùò ÏΩòÌÖêÏ∏†
        </p>
      </div>

      {/* ÏΩòÌÖêÏ∏† Í∑∏Î¶¨Îìú/Î¶¨Ïä§Ìä∏ */}
      <div className={viewMode === 'grid'
        ? "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6"
        : "space-y-4"
      }>
        {contents
          .filter(content => content && content.id) // Ïú†Ìö®Ìïú ÏΩòÌÖêÏ∏†Îßå Î†åÎçîÎßÅ
          .map((content, index) => (
            <ContentCard
              key={`explore-content-${content.id}-${index}`} // Îçî Í≥†Ïú†Ìïú ÌÇ§ ÏÉùÏÑ±
              content={content}
              creatorName={content.creatorName}
              creatorImage={content.creatorImage}
              isCreator={content.isCreator}
              onLike={handleLike}
              searchQuery={filters.query}
            />
          ))
        }
      </div>

      {/* Îçî Î≥¥Í∏∞ Î≤ÑÌäº */}
      {hasMore && (
        <div className="text-center">
          <Button
            onClick={() => loadContents(true)}
            disabled={loadingMore}
            variant="outline"
            size="lg"
          >
            {loadingMore ? (
              <>
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                Î°úÎî© Ï§ë...
              </>
            ) : (
              'Îçî Î≥¥Í∏∞'
            )}
          </Button>
        </div>
      )}

      {/* Í≤ÄÏÉâ ÏÑ±Îä• Î™®ÎãàÌÑ∞ */}
      <SearchPerformanceMonitor
        searchData={searchPerformance}
        isVisible={showPerformanceMonitor}
      />
    </div>
  );
}
